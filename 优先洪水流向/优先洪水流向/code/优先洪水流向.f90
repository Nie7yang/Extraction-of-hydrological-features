    !◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇
    !◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◆◆◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇
    !◇◇◇◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◇◇◇◇◇◇◇◇◇◇◇◇◆◆◆◇◇◇◇◇◇◇◇◇◇◇◆◆◆◆◆◆◆◇◇◇◇◇◇◇◇◇◇◇◇
    !◇◇◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◇◇◇◇◇◇◇◇◇◇◇◇◇◆◆◆◇◇◇◇◇◇◇◇◇◇◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◇◇
    !◇◇◇◇◇◆◆◆◆◆◆◆◆◆◆◆◇◇◇◇◇◇◇◇◇◆◆◆◆◆◆◆◆◆◆◆◆◆◆◇◇◇◇◇◆◆◆◇◆◆◆◆◆◆◆◆◆◆◆◆◆◇◇
    !◇◇◇◇◇◆◆◆◆◆◆◆◆◆◆◆◇◇◇◇◇◇◇◇◇◆◆◆◆◆◆◆◆◆◆◆◆◆◆◇◇◇◇◇◆◆◆◇◆◆◇◆◆◆◇◇◇◇◆◆◇◇◇
    !◇◇◇◇◇◆◆◇◇◇◇◇◇◆◆◆◇◇◇◇◇◇◇◇◇◆◆◆◇◇◇◇◇◇◇◇◆◆◇◇◇◇◇◇◆◆◆◇◆◆◇◆◆◆◇◇◇◇◆◆◇◇◇
    !◇◇◇◇◇◆◆◆◆◆◆◆◆◆◆◆◇◇◇◇◇◇◇◇◇◆◆◆◇◇◇◇◇◇◇◇◆◆◆◇◇◇◇◇◆◆◆◆◆◆◇◆◆◆◇◇◇◇◆◆◇◇◇
    !◇◇◇◇◇◆◆◇◇◆◆◆◆◆◆◆◆◆◇◇◇◇◇◇◇◆◆◆◆◆◆◆◆◆◆◆◆◆◆◇◇◇◇◇◆◆◆◆◆◆◇◆◆◆◇◇◇◇◆◆◇◇◇
    !◇◇◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◇◇◇◇◇◇◆◆◆◆◆◆◆◆◆◆◆◆◆◇◇◇◇◇◇◆◆◆◆◆◆◇◆◆◆◆◆◆◆◆◆◇◇◇
    !◇◇◆◆◆◆◆◆◇◇◇◇◇◆◆◆◆◆◇◇◇◇◇◇◇◆◆◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◆◆◆◇◆◆◆◆◆◆◆◆◆◆◆◆◇◇◇
    !◇◇◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◇◇◇◇◇◇◇◆◆◆◆◆◆◆◆◆◆◆◆◆◇◇◇◇◇◇◆◆◆◇◇◆◆◆◆◆◇◇◇◇◆◆◇◇◇
    !◇◇◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◆◇◇◇◇◇◇◇◆◆◆◆◆◆◆◆◆◆◆◆◆◆◇◇◇◇◇◆◆◆◇◇◆◆◆◆◆◇◇◇◇◆◆◇◇◇
    !◇◇◇◆◆◆◇◆◆◆◆◆◆◇◇◆◆◇◇◇◇◇◇◇◇◆◆◆◆◇◇◇◇◇◇◇◆◆◆◇◇◇◇◇◆◆◆◆◆◆◆◆◆◆◇◇◇◇◆◆◇◇◇
    !◇◇◇◇◆◆◆◆◆◆◇◆◆◆◆◆◆◇◇◇◇◇◇◇◆◆◆◆◆◇◇◇◇◇◇◇◆◆◇◇◇◇◇◇◆◆◆◆◆◆◆◆◆◆◇◇◇◇◆◆◇◇◇
    !◇◇◇◇◆◆◆◆◆◆◇◇◆◆◆◆◇◇◇◇◇◇◇◇◆◆◆◆◆◇◇◇◇◇◇◇◆◆◇◇◇◇◇◇◆◆◆◆◆◆◇◆◆◆◆◆◆◆◆◆◇◇◇
    !◇◇◇◇◆◆◆◆◆◆◆◇◆◆◆◆◇◇◇◇◇◇◇◆◆◆◇◆◆◆◆◆◆◆◆◆◆◆◇◇◇◇◇◇◆◆◆◇◇◇◇◆◆◆◆◆◆◆◆◆◆◇◇
    !◇◆◆◆◆◆◆◇◆◆◆◆◆◆◆◆◆◆◆◆◇◇◇◆◆◆◇◆◆◆◆◆◆◆◆◆◆◆◆◇◇◇◇◇◆◆◆◇◇◇◇◆◆◆◇◇◇◇◆◆◆◇◇
    !◇◇◆◆◆◆◇◇◇◆◆◆◆◇◇◆◆◆◆◇◇◇◇◆◆◇◇◆◆◇◇◇◇◇◇◇◆◆◆◇◇◇◇◇◆◆◆◇◇◇◇◆◆◆◇◇◇◇◆◆◇◇◇
    !◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇
    !◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇    长安大学——聂启阳   ◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇
    !◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇       2018年10月     ◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇
    !◇◇    程序基于《一种融合Priority-Flood算法与D8算法特点的河网提取方式》   ◇◇
    !◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇

    MODULE GongYongShuZu                        !**模块置于引用之前编译**

    REAL,ALLOCATABLE  ::  DuiLie1(:,:),DuiLie2(:,:),DuiLie3(:,:)
    ! 后期定义几个n*3的数组，第一列存值，第二列存x坐标，第三列存y坐标。
    ! 注意：由于是用的浮点数矩阵，取用x，y坐标时需要进行取整运算int()。
    ! DuiLie1：最小优先队列。DuiLie2：最大优先队列。DuiLie3：快速队列。
    ! 最小优先列队：边界栅格以及上坡栅格。
    ! 最大优先队列：下坡栅格。
    ! 快速队列：平地栅格。
    INTEGER,ALLOCATABLE  ::  DEM(:,:),DIR(:,:)
    INTEGER  ::  hang,lie,gc
    ENDMODULE


    program YouXianHongShuiAndD8
    use GongYongShuZu
    implicit none

    REAL YaRu,Tanchu
    INTEGER i,j,m,n,xx,yy
    CHARACTER DATE
    CHARACTER(len=30) DATE1,DATE2,DATE3,DATE4,DATE5,DATE6
    REAL gaocha,gcc,DemMin
    REAL time_begin , time_star , time_end
    
    ALLOCATE (DuiLie1(0:10000000,3),DuiLie2(0:10000000,3),DuiLie3(0:10000000,3))
    
    
    call cpu_time(time_star)
    DuiLie1=-8888
    DuiLie2=-8888
    DuiLie3=-8888
    DuiLie1(0,1)=0
    DuiLie2(0,1)=0
    DuiLie3(0,1)=0
    !每个DuiLie数组（0，1）位存放有效大小，可以由此为判断数组是否不够用再扩大。
    !以减少动态数组反复操作时间，加快程序速度。

    OPEN (111,FILE='dem.txt')
    OPEN (222,FILE='dir.txt')

    READ (111,'(A30)') DATE1
    READ (111,'(A30)') DATE2
    READ (111,'(A30)') DATE3
    READ (111,'(A30)') DATE4
    READ (111,'(A30)') DATE5
    READ (111,'(A30)') DATE6
    CLOSE (111)
    !读取栅格文件信息表头，为之后输出栅格图做准备。
    OPEN (111,FILE='dem.txt')
    READ (111,*) DATE,lie	!读取总列数
    READ (111,*) DATE,hang	!读取总行数
    READ (111,*)
    READ (111,*)
    READ (111,*) DATE,gc	!网格边长
    READ (111,*)
    allocate (DEM(hang,lie),DIR(hang,lie))
    DO m=1,hang
        READ (111,*) (DEM(m,n),n=1,lie)
    END DO
    DO n=1,lie
        DO m=1,hang
            DIR(m,n)=-9999
            if(DEM(m,n)>=0)then
                xx=m
                yy=n
                call BianJiePanDuan(xx,yy)
            end if
        END DO
    END DO
    !筛选DEM边界栅格单元，并用D8确认流向，若遇到本身是洼地或者平地的则直接外流。
    write(*,*)'**********  开始计算  **********'
    !◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇
    !◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇  计算核心  ◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇
    !◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇
    DO WHILE ((duilie1(0,1)+duilie2(0,1)+duilie3(0,1))>0)
        if(duilie3(0,1)>0)then
            call KuaiSuTan(TanChu,xx,yy)
            call LinYuPanDuan(xx,yy)
        elseif(duilie2(0,1)>0)then
            call ZuiDaTan(TanChu,xx,yy)
            call LinYuPanDuan(xx,yy)
        else
            call ZuiXiaoTan(TanChu,xx,yy)
            call LinYuPanDuan(xx,yy)
        endif
    END DO

    WRITE (222,'(A30)') DATE1
    WRITE (222,'(A30)') DATE2
    WRITE (222,'(A30)') DATE3
    WRITE (222,'(A30)') DATE4
    WRITE (222,'(A30)') DATE5
    WRITE (222,'(A30)') DATE6

    do i = 1,hang
        write(222,'(<lie>I7)') (DIR(i,j), j = 1,lie)
    enddo
    write(*,*)'##########    成功    ##########'
    CLOSE (111)
    CLOSE (222)

    DEALLOCATE (DuiLie1,DuiLie2,DuiLie3)
    DEALLOCATE (dem,dir)
    call cpu_time(time_end)
    time_begin=time_end-time_star
    write(*,*)'计算耗时：',time_begin,'s'
    read(*,*)
    end program YouXianHongShuiAndD8

    !◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇ 子程序 ◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇◇

    subroutine ZuiXiaoJia(YaRu,xx,yy)
    use GongYongShuZu
    implicit none

    real YaRu
    integer i,xx,yy

    i=DuiLie1(0,1)

    DuiLie1(i+1,1)=YaRu
    DuiLie1(i+1,2)=xx
    DuiLie1(i+1,3)=yy

    DuiLie1(0,1)=DuiLie1(0,1)+1

    return
    end subroutine ZuiXiaoJia

    subroutine ZuiXiaoTan(TanChu,xx,yy)
    use GongYongShuZu
    implicit none
    ! 最小优先队列的弹出操作子函数，最小优先队列的排序将新最小值置于末尾并进行弹出并缩短操作。
    ! i:DuiLie1长度。TanChu：弹出队列的数值。xx：弹出队列数值的x坐标。yy：弹出队列数值的y坐标。

    real TanChu,Mini(1,3)
    integer i,j,xx,yy
    integer,ALLOCATABLE  ::  ZuiXiao(:)

    ALLOCATE (ZuiXiao(1))

    i=DuiLie1(0,1)

    ZuiXiao=MinLoc(DuiLie1(1:i,1))

    j=ZuiXiao(1)

    Mini(1,1)=DuiLie1(j,1)
    Mini(1,2)=DuiLie1(j,2)
    Mini(1,3)=DuiLie1(j,3)

    DuiLie1(j,1)=DuiLie1(i,1)
    DuiLie1(j,2)=DuiLie1(i,2)
    DuiLie1(j,3)=DuiLie1(i,3)

    TanChu=Mini(1,1)
    xx=Mini(1,2)
    yy=Mini(1,3)

    DuiLie1(0,1)=DuiLie1(0,1)-1

    return
    end subroutine ZuiXiaoTan

    subroutine ZuiDaJia(YaRu,xx,yy)
    use GongYongShuZu
    implicit none

    real YaRu
    integer i,xx,yy

    i=DuiLie2(0,1)

    DuiLie2(i+1,1)=YaRu
    DuiLie2(i+1,2)=xx
    DuiLie2(i+1,3)=yy

    DuiLie2(0,1)=DuiLie2(0,1)+1

    return
    end subroutine ZuiDaJia

    subroutine ZuiDaTan(TanChu,xx,yy)
    use GongYongShuZu
    implicit none
    ! 最大优先队列的弹出操作子函数，最大优先队列的排序将新最大值置于末尾并进行弹出并缩短操作。
    ! i:DuiLie2长度。TanChu：弹出队列的数值。xx：弹出队列数值的x坐标。yy：弹出队列数值的y坐标。

    real TanChu,maxx(1,3)
    integer i,j,xx,yy
    integer,ALLOCATABLE  ::  ZuiDa(:)

    ALLOCATE (ZuiDa(1))

    i=DuiLie2(0,1)

    ZuiDa=MaxLoc(DuiLie2(1:i,1))

    j=ZuiDa(1)

    maxx(1,1)=DuiLie2(j,1)
    maxx(1,2)=DuiLie2(j,2)
    maxx(1,3)=DuiLie2(j,3)

    DuiLie2(j,1)=DuiLie2(i,1)
    DuiLie2(j,2)=DuiLie2(i,2)
    DuiLie2(j,3)=DuiLie2(i,3)

    TanChu=maxx(1,1)
    xx=maxx(1,2)
    yy=maxx(1,3)

    DuiLie2(0,1)=DuiLie2(0,1)-1

    return
    end subroutine ZuiDaTan

    subroutine KuaiSuJia(YaRu,xx,yy)
    use GongYongShuZu
    implicit none

    real YaRu
    integer i,xx,yy

    i=DuiLie3(0,1)

    DuiLie3(i+1,1)=YaRu
    DuiLie3(i+1,2)=xx
    DuiLie3(i+1,3)=yy

    DuiLie3(0,1)=DuiLie3(0,1)+1

    return
    end subroutine KuaiSuJia

    subroutine KuaiSuTan(TanChu,xx,yy)
    use GongYongShuZu
    implicit none
    ! 最大优先队列的弹出操作子函数，最大优先队列的排序将新最大值置于末尾并进行弹出并缩短操作。
    ! i:DuiLie3长度。TanChu：弹出队列的数值。xx：弹出队列数值的x坐标。yy：弹出队列数值的y坐标。

    real TanChu
    integer i,xx,yy

    i=DuiLie3(0,1)

    TanChu=DuiLie3(1,1)
    xx=DuiLie3(1,2)
    yy=DuiLie3(1,3)

    DuiLie3(1:i-1,:)=DuiLie3(2:i,:)

    DuiLie3(0,1)=DuiLie3(0,1)-1

    return
    end subroutine KuaiSuTan

    subroutine BianJiePanDuan(xx,yy)
    use GongYongShuZu
    implicit none
    integer BianJie,xx,yy,m,n
    real YaRu

    BianJie=1
    DO m=xx-1,xx+1
        DO n=yy-1,yy+1
            if(m<=0.or.m>hang.or.n<=0.or.n>lie)then
                BianJie=0
            elseif(DEM(m,n)<0)then
                BianJie=0
            endif
        END DO
    END DO
    !用BianJie参数表征是否边界栅格，四周有超出图幅范围的和空值则为边界栅格。是边界则BinJie为0，非边界为1。
    if(BianJie==0)then
        YaRu=DEM(xx,yy)
        call ZuiXiaoJia(YaRu,xx,yy)
        call GetBianJieDIR(xx,yy)
    end if
    return
    end subroutine BianJiePanDuan

    subroutine GetBianJieDIR(xx,yy)
    use GongYongShuZu
    implicit none
    integer xx,yy

    if(xx+1>hang)then
        dir(xx,yy)=4
    elseif(xx-1<=0)then
        dir(xx,yy)=64
    elseif(yy+1>lie)then
        dir(xx,yy)=1
    elseif(yy-1<=0)then
        dir(xx,yy)=16
    elseif(dem(xx,yy+1)<0)then
        dir(xx,yy)=1
    elseif(dem(xx+1,yy+1)<0)then
        dir(xx,yy)=2
    elseif(dem(xx+1,yy)<0)then
        dir(xx,yy)=4
    elseif(dem(xx+1,yy-1)<0)then
        dir(xx,yy)=8
    elseif(dem(xx,yy-1)<0)then
        dir(xx,yy)=16
    elseif(dem(xx-1,yy-1)<0)then
        dir(xx,yy)=32
    elseif(dem(xx-1,yy)<0)then
        dir(xx,yy)=64
    elseif(dem(xx-1,yy+1)<0)then
        dir(xx,yy)=128
    endif

    return
    end subroutine GetBianJieDIR

    subroutine GetShangPoDIR(xx,yy)
    use GongYongShuZu
    implicit none
    REAL,ALLOCATABLE  ::  PoJiang(:,:)
    INTEGER,ALLOCATABLE  ::  ZuiDa(:)
    integer m,n,xx,yy,s,t,i
    real gcc,YaRu
    ALLOCATE (PoJiang(3,3),ZuiDa(2))

    gcc = FLOAT(GC)
    s=0
    DO m=xx-1,xx+1
        s=s+1
        t=0
        DO n=yy-1,yy+1
            t=t+1
            if((DEM(m,n)<DEM(xx,yy)).and.(DIR(m,n)>0))then
                if(t==2.or.s==2)then
                    PoJiang(s,t)=(DEM(xx,yy)-DEM(m,n))/gcc
                else
                    PoJiang(s,t)=(DEM(xx,yy)-DEM(m,n))/(gcc*sqrt(2.0))
                endif
            else
                PoJiang(s,t)=0.0
            endif
        END DO
    END DO
    !MaxVal( S ) , MinVal( S ) 最大值，最小值
    !MaxLoc( S ) , MinLoc( S ) 最大值下标，最小值下标
    ZuiDa=MaxLoc(PoJiang)
    !上坡栅格采用最大坡降确定流向后，压入最小优先队列。
    if(ZuiDa(1)==1.and.ZuiDa(2)==1)then
        DIR(xx,yy)=32
    elseif(ZuiDa(1)==1.and.ZuiDa(2)==2)then
        DIR(xx,yy)=64
    elseif(ZuiDa(1)==1.and.ZuiDa(2)==3)then
        DIR(xx,yy)=128
    elseif(ZuiDa(1)==2.and.ZuiDa(2)==1)then
        DIR(xx,yy)=16
    elseif(ZuiDa(1)==2.and.ZuiDa(2)==3)then
        DIR(xx,yy)=1
    elseif(ZuiDa(1)==3.and.ZuiDa(2)==1)then
        DIR(xx,yy)=8
    elseif(ZuiDa(1)==3.and.ZuiDa(2)==2)then
        DIR(xx,yy)=4
    elseif(ZuiDa(1)==3.and.ZuiDA(2)==3)then
        DIR(xx,yy)=2
    endif

    YaRu=DEM(xx,yy)
    call ZuiXiaoJia(YaRu,xx,yy)

    DEALLOCATE (PoJiang,ZuiDa)

    return
    end subroutine GetShangPoDIR

    subroutine GetXiaPoDIR(xx,yy)
    use GongYongShuZu
    implicit none
    REAL,ALLOCATABLE  ::  PoJiang(:,:)
    INTEGER,ALLOCATABLE  ::  ZuiXiao(:)
    integer m,n,xx,yy,s,t,i
    real gcc,YaRu
    ALLOCATE (PoJiang(3,3),ZuiXiao(2))

    gcc = FLOAT(GC)
    s=0
    DO m=xx-1,xx+1
        s=s+1
        t=0
        DO n=yy-1,yy+1
            t=t+1
            if((DEM(m,n)>DEM(xx,yy)).and.(DIR(m,n)>0))then
                if(t==2.or.s==2)then
                    PoJiang(s,t)=(DEM(m,n)-DEM(xx,yy))/gcc
                else
                    PoJiang(s,t)=(DEM(m,n)-DEM(xx,yy))/(gcc*sqrt(2.0))
                endif
            else
                PoJiang(s,t)=666
            endif
        END DO
    END DO
    !MaxVal( S ) , MinVal( S ) 最大值，最小值
    !MaxLoc( S ) , MinLoc( S ) 最大值下标，最小值下标
    ZuiXiao=MinLoc(PoJiang)
    if(ZuiXiao(1)==1.and.ZuiXiao(2)==1)then
        DIR(xx,yy)=32
    elseif(ZuiXiao(1)==1.and.ZuiXiao(2)==2)then
        DIR(xx,yy)=64
    elseif(ZuiXiao(1)==1.and.ZuiXiao(2)==3)then
        DIR(xx,yy)=128
    elseif(ZuiXiao(1)==2.and.ZuiXiao(2)==1)then
        DIR(xx,yy)=16
    elseif(ZuiXiao(1)==2.and.ZuiXiao(2)==3)then
        DIR(xx,yy)=1
    elseif(ZuiXiao(1)==3.and.ZuiXiao(2)==1)then
        DIR(xx,yy)=8
    elseif(ZuiXiao(1)==3.and.ZuiXiao(2)==2)then
        DIR(xx,yy)=4
    elseif(ZuiXiao(1)==3.and.ZuiXiao(2)==3)then
        DIR(xx,yy)=2
    endif

    YaRu=DEM(xx,yy)
    call ZuiDaJia(YaRu,xx,yy)

    DEALLOCATE (PoJiang,ZuiXiao)

    return
    end subroutine GetXiaPoDIR

    subroutine LinYuPanDuan(xx,yy)
    use GongYongShuZu
    implicit none

    integer xx,yy,mm,nn
    real YaRu

    !当dir值小于0时才表示这个网格没有定流向
    if(yy+1<=lie)then
        if(DIR(xx,yy+1)<0.and.DEM(xx,yy+1)>0)then
            if(DEM(xx,yy+1)>DEM(xx,yy))then !上坡
                mm=xx
                nn=yy+1
                call GetShangPoDIR(mm,nn)
            elseif(DEM(xx,yy+1)<DEM(xx,yy))then !下坡
                mm=xx
                nn=yy+1
                call GetXiaPoDIR(mm,nn)
            else
                DIR(xx,yy+1)=16
                YaRu=DEM(xx,yy+1)
                mm=xx
                nn=yy+1
                call KuaiSuJia(YaRu,mm,nn)
            endif
        endif
    endif

    if(xx+1<=hang.and.yy+1<=lie)then
        if(DIR(xx+1,yy+1)<0.and.DEM(xx+1,yy+1)>0)then
            if(DEM(xx+1,yy+1)>DEM(xx,yy))then !上坡
                mm=xx+1
                nn=yy+1
                call GetShangPoDIR(mm,nn)
            elseif(DEM(xx+1,yy+1)<DEM(xx,yy))then !下坡
                mm=xx+1
                nn=yy+1
                call GetXiaPoDIR(mm,nn)
            else
                DIR(xx+1,yy+1)=32
                YaRu=DEM(xx+1,yy+1)
                mm=xx+1
                nn=yy+1
                call KuaiSuJia(YaRu,mm,nn)
            endif
        endif
    endif

    if(xx+1<=hang)then
        if(DIR(xx+1,yy)<0.and.DEM(xx+1,yy)>0)then
            if(DEM(xx+1,yy)>DEM(xx,yy))then !上坡
                mm=xx+1
                nn=yy
                call GetShangPoDIR(mm,nn)
            elseif(DEM(xx+1,yy)<DEM(xx,yy))then !下坡
                mm=xx+1
                nn=yy
                call GetXiaPoDIR(mm,nn)
            else
                DIR(xx+1,yy)=64
                YaRu=DEM(xx+1,yy)
                mm=xx+1
                nn=yy
                call KuaiSuJia(YaRu,mm,nn)
            endif
        endif
    endif

    if(xx+1<=hang.and.yy-1>0)then
        if(DIR(xx+1,yy-1)<0.and.DEM(xx+1,yy-1)>0)then
            if(DEM(xx+1,yy-1)>DEM(xx,yy))then !上坡
                mm=xx+1
                nn=yy-1
                call GetShangPoDIR(mm,nn)
            elseif(DEM(xx+1,yy-1)<DEM(xx,yy))then !下坡
                mm=xx+1
                nn=yy-1
                call GetXiaPoDIR(mm,nn)
            else
                DIR(xx+1,yy-1)=128
                YaRu=DEM(xx+1,yy-1)
                mm=xx+1
                nn=yy-1
                call KuaiSuJia(YaRu,mm,nn)
            endif
        endif
    endif

    if(yy-1>0)then
        if(DIR(xx,yy-1)<0.and.DEM(xx,yy-1)>0)then
            if(DEM(xx,yy-1)>DEM(xx,yy))then !上坡
                mm=xx
                nn=yy-1
                call GetShangPoDIR(mm,nn)
            elseif(DEM(xx,yy-1)<DEM(xx,yy))then !下坡
                mm=xx
                nn=yy-1
                call GetXiaPoDIR(mm,nn)
            else
                DIR(xx,yy-1)=1
                YaRu=DEM(xx,yy-1)
                mm=xx
                nn=yy-1
                call KuaiSuJia(YaRu,mm,nn)
            endif
        endif
    endif

    if(xx-1>0.and.yy-1>0)then
        if(DIR(xx-1,yy-1)<0.and.DEM(xx-1,yy-1)>0)then
            if(DEM(xx-1,yy-1)>DEM(xx,yy))then !上坡
                mm=xx-1
                nn=yy-1
                call GetShangPoDIR(mm,nn)
            elseif(DEM(xx-1,yy-1)<DEM(xx,yy))then !下坡
                mm=xx-1
                nn=yy-1
                call GetXiaPoDIR(mm,nn)
            else
                DIR(xx-1,yy-1)=2
                YaRu=DEM(xx-1,yy-1)
                mm=xx-1
                nn=yy-1
                call KuaiSuJia(YaRu,mm,nn)
            endif
        endif
    endif

    if(xx-1>0)then
        if(DIR(xx-1,yy)<0.and.DEM(xx-1,yy)>0)then
            if(DEM(xx-1,yy)>DEM(xx,yy))then !上坡
                mm=xx-1
                nn=yy
                call GetShangPoDIR(mm,nn)
            elseif(DEM(xx-1,yy)<DEM(xx,yy))then !下坡
                mm=xx-1
                nn=yy
                call GetXiaPoDIR(mm,nn)
            else
                DIR(xx-1,yy)=4
                YaRu=DEM(xx-1,yy)
                mm=xx-1
                nn=yy
                call KuaiSuJia(YaRu,mm,nn)
            endif
        endif
    endif

    if(xx-1>0.and.yy+1<lie)then
        if(DIR(xx-1,yy+1)<0.and.DEM(xx-1,yy+1)>0)then
            if(DEM(xx-1,yy+1)>DEM(xx,yy))then !上坡
                mm=xx-1
                nn=yy+1
                call GetShangPoDIR(mm,nn)
            elseif(DEM(xx-1,yy+1)<DEM(xx,yy))then !下坡
                mm=xx-1
                nn=yy+1
                call GetXiaPoDIR(mm,nn)
            else
                DIR(xx-1,yy+1)=8
                YaRu=DEM(xx-1,yy+1)
                mm=xx-1
                nn=yy+1
                call KuaiSuJia(YaRu,mm,nn)
            endif
        endif
    endif

    return
    end subroutine LinYuPanDuan
